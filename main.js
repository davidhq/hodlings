// Generated by LiveScript 1.6.0
(function(){
  var display, lastRows, displayLatestValues, interval;
  var rest = require('rest');
  var timespan = require('timespan');
  var ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, lines = ref$.lines, sum = ref$.sum, each = ref$.each;
  var path = require('path');
  var crypto = require('crypto');
  var homedir = require('homedir');
  var chalk = require('chalk');
  var ref$ = require('fs'), readFileSync = ref$.readFileSync, writeFileSync = ref$.writeFileSync, existsSync = ref$.existsSync, mkdirSync = ref$.mkdirSync, watchFile = ref$.watchFile;
  var dataUrl = "https://api.coinmarketcap.com/v1/";

  var client = rest.wrap(require('rest/interceptor/mime')).wrap(require('rest/interceptor/errorCode')).wrap(require('rest/interceptor/retry'), {
    initial: timespan.fromSeconds(5).totalMilliseconds()
  }).wrap(require('rest/interceptor/timeout'), {
    timeout: timespan.fromSeconds(80).totalMilliseconds()
  }).wrap(require('rest/interceptor/pathPrefix'), {
    prefix: dataUrl
  });

  var Promise = require('bluebird');
  var portfolio = require('./lib/portfolio');
  var cliOptions = require('./lib/cli-options');

  var options = cliOptions.getOptions();
  portfolio.ensureMainExists();

  if (!existsSync(options.file)) {
    console.log(chalk.red("\nFile " + options.file + " not found..."));
    return;
  }

  var renderer = new options.Renderer(options);
  var dataDir = path.join(__dirname, 'data');
  if (!existsSync(dataDir)) {
    mkdirSync(dataDir);
  }
  var lastValuesFile = path.join(dataDir, './data.json');

  var execute = function(cb){
    cb == null && (cb = console.log);
    return function(it){
      return it.then(cb);
    }(
    function(it){
      return it.then(renderer.render);
    }(
    getLatest(
    portfolio.load(options.file))));
  };

  if (options.watch) {
    display = require('charm')(process).cursor(false);
    process.on('exit', function(){
      display.cursor(true);
      return console.log();
    });
    lastRows = 0;
    displayLatestValues = function(){
      if (lastRows) {
        display.up(lastRows - 1).left(999).cursor(true);
      }
      return function(it){
        return it['catch'](function(){});
      }(
      execute(function(it){
        display.erase('down').write(it).cursor(false);
        return lastRows = function(it){
          return it.length;
        }(
        lines(
        it));
      }));
    };
    displayLatestValues();
    interval = timespan.fromSeconds(600).totalMilliseconds();
    setInterval(displayLatestValues, interval);
    watchFile(options.file, function(curr, prev){
      return displayLatestValues();
    });
  } else {
    execute()['catch'](function(e){
      throw e;
      process.exit(-1);
    });
  }
  function findCurrency(currencies, id_or_symbol){
    var currency;
    currency = currencies.find(function(currency){
      return currency.id.toLowerCase() === id_or_symbol.toLowerCase();
    });
    return currency
      ? currency
      : currencies.find(function(currency){
        return currency.symbol.toLowerCase() === id_or_symbol.toLowerCase();
      });
  }
  function writeLastValues(details, currencies, totals, hodlingsSignature){
    var lastValues;
    lastValues = {
      price_btc_usd: findCurrency(currencies, "bitcoin").price_usd,
      totals: totals,
      hodlingsSignature: hodlingsSignature,
      portfolio: map(function(entry){
        return {
          id: findCurrency(currencies, entry.id).id,
          price_btc: entry.priceBtc
        };
      })(
      details)
    };
    return writeFileSync(lastValuesFile, JSON.stringify(lastValues, null, 2));
  }
  function getLatest(hodlings){
    var hodlingsSignature, processData, convertString, makeRequest, lastValues;
    hodlingsSignature = crypto.createHash('md5').update(JSON.stringify(hodlings)).digest("hex");
    processData = function(global, currencies, lastValues){
      var bitcoin, ethereum, getValue, details, grandTotal, grandTotalEth, grandTotalBtc, fx, flippening, ethereum_percentage_of_market_cap, totals, totalsChange;
      bitcoin = findCurrency(currencies, "bitcoin");
      ethereum = findCurrency(currencies, "ethereum");
      getValue = function(arg$){
        var coin, amount, currency, fx, price, priceBtc, volume, amountForCurrency, value, valueBtc, valueEth, changes, changeEthWeek, changeBtcWeek, lastCurrency, price_btc_usd;
        coin = arg$.coin, amount = arg$.amount;
        currency = findCurrency(currencies, coin);
        if (currency == null) {
          console.error("Unknown coin: " + coin);
          return;
        }
        fx = options.convert.toLowerCase();
        price = parseFloat(
        currency["price_" + fx]);
        priceBtc = parseFloat(
        currency.price_btc);
        volume = parseFloat(
        currency["24h_volume_" + fx]) / parseFloat(
        bitcoin["24h_volume_" + fx]);
        amountForCurrency = curry$(function(x$, y$){
          return x$ * y$;
        })(amount);
        value = amountForCurrency(price);
        valueBtc = amountForCurrency(priceBtc);
        valueEth = valueBtc / ethereum.price_btc;
        changes = {};
        changeEthWeek = parseFloat(
        ethereum.percent_change_7d);
        changes.weekVsEth = (currency.percent_change_7d - changeEthWeek) / 100;
        changeBtcWeek = parseFloat(
        bitcoin.percent_change_7d);
        changes.weekVsBtc = (currency.percent_change_7d - changeBtcWeek) / 100;
        if (lastValues) {
          lastCurrency = lastValues.portfolio.find(function(entry){
            return entry.id === findCurrency(currencies, coin).id;
          });
          if (lastCurrency) {
            price_btc_usd = parseFloat(
            bitcoin.price_usd);
            changes.vsUsd = (price_btc_usd * priceBtc) / (lastCurrency.price_btc * lastValues.price_btc_usd) - 1;
          }
        }
        return {
          count: amount,
          value: value,
          valueBtc: valueBtc,
          valueEth: valueEth,
          price: price,
          priceBtc: priceBtc,
          changeVsUsd: changes.vsUsd || 0,
          changeWeekVsEth: changes.weekVsEth || 0,
          changeWeekVsBtc: changes.weekVsBtc || 0,
          id: coin,
          symbol: currency.symbol,
          amount: amount,
          volume: volume,
          marketCap: parseFloat(
          currency["market_cap_" + fx]),
          rank: currency.rank,
          currency: currency
        };
      };
      details = filter(function(it){
        return it != null;
      })(
      map(getValue)(
      hodlings));
      grandTotal = sum(
      map(function(it){
        return it.value;
      })(
      details));
      grandTotalEth = sum(
      map(function(it){
        return it.valueEth;
      })(
      details));
      grandTotalBtc = sum(
      map(function(it){
        return it.valueBtc;
      })(
      details));
      each(function(it){
        return it.percentage = it.value / grandTotal;
      })(
      details);
      fx = options.convert.toLowerCase();
      flippening = parseFloat(
      ethereum["market_cap_" + fx]) / parseFloat(
      bitcoin["market_cap_" + fx]);
      ethereum_percentage_of_market_cap = 100 * parseFloat(
      ethereum["market_cap_" + fx]) / parseFloat(
      global["total_market_cap_" + fx]);
      totals = {
        value: grandTotal,
        currency: fx,
        eth: grandTotalEth,
        btc: grandTotalBtc
      };
      writeLastValues(details, currencies, totals, hodlingsSignature);
      totalsChange = {};
      if (lastValues && lastValues.hodlingsSignature && lastValues.hodlingsSignature === hodlingsSignature) {
        if (lastValues.totals.currency === fx) {
          totalsChange.fx = grandTotal / lastValues.totals.value - 1;
          totalsChange.fxDiff = grandTotal - lastValues.totals.value;
        }
        if (lastValues.totals.eth) {
          totalsChange.eth = grandTotalEth / lastValues.totals.eth - 1;
        }
        if (lastValues.totals.btc) {
          totalsChange.btc = grandTotalBtc / lastValues.totals.btc - 1;
        }
      }
      return {
        grandTotal: grandTotal,
        grandTotalEth: grandTotalEth,
        grandTotalBtc: grandTotalBtc,
        totalsChange: totalsChange,
        details: details,
        flippening: flippening,
        ethereum_percentage_of_market_cap: ethereum_percentage_of_market_cap,
        global: global
      };
    };
    convertString = (function(){
      switch (false) {
      case !/^USD$/i.test(options.convert):
        return "?limit=0";
      default:
        return "?convert=" + options.convert + "&limit=0";
      }
    }());
    makeRequest = function(url){
      return function(it){
        return it.entity();
      }(
      client(
      url + convertString));
    };
    lastValues = undefined;
    if (existsSync(lastValuesFile)) {
      try {
        lastValues = JSON.parse(readFileSync(lastValuesFile));
      } catch (e$) {}
    }
    return Promise.join(makeRequest('global/'), makeRequest('ticker/').then(function(entity){
      return entity;
    }), lastValues, processData)['catch'](function(e){
      console.error("!!! Error accessing service: " + e);
      throw e;
    });
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
